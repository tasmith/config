#+TITLE: Todd's Emacs Configuration
#+OPTIONS: toc:4 h:4
#+STARTUP: showeverything
#+PROPERTY: header-args:emacs-lisp   :tangle "~/.emacs.d/todd.el"

* About this file

This file is my personal Emacs configuration file. Written as an org mode literate
program, this file must be tangled with the emacs command =M-x org-bable-tangle=
(=C-c C-v t=) to generate the actual file =todd.el=,
which is symlinked to the name =init.el= in my =~/.emacs.d= directory.

** References and Thanks

My configuration is greatly influenced by the numerous clever ideas incorporated
in many other Emacs user's configuration files.

  * [[https://raw.githubusercontent.com/sachac/.emacs.d/gh-pages/Sacha.org][Sacha Chua's Emacs Configuration]]
  * Samuel Barreto's [[https://sam217pa.github.io/2016/09/23/keybindings-strategies-in-emacs/][Keybinding Strategies in Emacs]] and [[https://sam217pa.github.io/2016/08/30/how-to-make-your-own-spacemacs/][Make your own Spacemacs]]
  * Aaron Bieber's [[https://blog.aaronbieber.com/2016/11/24/org-capture-from-anywhere-on-your-mac.html][Org Capture from Anywhere on Your Mac]]
  * Filipe Silva's [[https://github.com/ninrod/dotfiles/blob/master/emacs/boot.org][Ninrod Emacs Configuration]]
  * [[http://emacs-bootstrap.com/][Emacs Bootstrap]]

* Base configuration

** First a bit of information about the file and me

#+BEGIN_SRC emacs-lisp :padline no
;;; emacs configuration        -*- no-byte-compile: t -*-
;;; This file is a generated file, so do not edit this file.
;;; The actual configuration is stored in the source file
;;; for this file, see `~/.emacs.d/todd.org'.

(setq user-full-name "Todd Smith")
(load "~/.emacs-secrets" t)  ;; not on github...I hope!
#+END_SRC

** Emacs package system

I use the package system extensively and the =use-package= command to
install, configure, and initialize the packages in my Emacs setup. There
are a few steps to prepare for it.

*** Package sources

For better security, I use =https= URL's for all of my package sources now.

#+BEGIN_SRC emacs-lisp
(package-initialize)
(setq package-archives '(("org"   . "https://orgmode.org/elpa/")
                         ("elpy"  . "https://jorgenschaefer.github.io/packages/")
			 ("gnu"   . "https://elpa.gnu.org/packages/")
			 ("melpa" . "https://melpa.org/packages/")))
#+END_SRC

*** Use package

John Wiegley's =use-package= is a great way to keep configuration
of installed packages organized. First, make sure it is installed,
and install packages =delight= and =bind-key= which are dependencies
for use package.

#+BEGIN_SRC emacs-lisp
(when (not package-archive-contents)
  (package-refresh-contents))
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))
#+END_SRC

Initialize a few =use-package= settings.

#+BEGIN_SRC emacs-lisp
(setq use-package-verbose t
      use-package-always-ensure t)
#+END_SRC

=use-package.el= is no longer needed at runtime, according to its documentation.

#+BEGIN_SRC emacs-lisp
(eval-when-compile
  (require 'use-package))
#+END_SRC

These two packages support the :delight and :bind keys in =use-package=.

#+BEGIN_SRC emacs-lisp
(use-package delight)
(use-package bind-key)
#+END_SRC

** Core Settings

*** Emacs customize system

I don't want customize settings, which are generated by the =customize=
commands of Emacs written in my init.el file so I provide an explicit
place for them to go. This is essential because my init.el file is
overwritten each time I tangle this file to generate it.

#+BEGIN_SRC emacs-lisp
(setq custom-file "~/.emacs.d/custom-settings.el")
#+END_SRC

*** UTF-8

Use UTF-8 /everywhere/.

#+BEGIN_SRC emacs-lisp
(set-charset-priority 'unicode)
(setq locale-coding-system   'utf-8)
(set-terminal-coding-system  'utf-8)
(set-keyboard-coding-system  'utf-8)
(set-selection-coding-system 'utf-8)
(prefer-coding-system        'utf-8)
(setq default-process-coding-system '(utf-8-unix . utf-8-unix))
#+END_SRC

*** Simple Customizations

#+BEGIN_SRC emacs-lisp
  (setq confirm-kill-emacs                  'y-or-n-p
        confirm-nonexistent-file-or-buffer  t
        save-interprogram-paste-before-kill t
        mouse-yank-at-point                 t

        ;; http://ergoemacs.org/emacs/emacs_stop_cursor_enter_prompt.html
        minibuffer-prompt-properties '(read-only t
                                                 point-entered minibuffer-avoid-prompt
                                                 face minibuffer-prompt))
#+END_SRC

*** PATH

The =exec-path= is like a shell's PATH environment variable that constrols the
search path used by Emacs for executing external programs and running =eshell= or other
shells inside of Emacs. When started in a windowing environment on MacOS (and
perhaps on Linux) the shell's normal startup files (e.g. =.profile=) may not have
been run by a parent process of Emacs. This means that Emacs won't have the user's
normal PATH.

The package =exec-path-from-shell= can alleviate the problem of setting a correct
PATH. It runs a shell (which will load the shell startup files) and obtains the
correct value of the shell's PATH. The package also, by default, sets the MANPATH.
It will set other environment variables from the shell as well that it finds in
the customizable variable =exec-path-from-shell-variables=.

See the Emacs =load-path=
variable to understand the search order Emacs uses when loading Emacs Lisp code,
an entirely different path.

#+BEGIN_SRC emacs-lisp
  ;; (setq exec-path (append exec-path '("/usr/local/bin/")))
  (use-package exec-path-from-shell
    :config
    (when (memq window-system '(ns x))
      (exec-path-from-shell-initialize)))
#+END_SRC

*** Emacs' files and directories

#+BEGIN_SRC emacs-lisp
(defconst my-data-dir  (expand-file-name "home/" user-emacs-directory))
#+END_SRC

*** Bookmarks

#+BEGIN_SRC emacs-lisp
  (defconst my-bookmark-default-file  (expand-file-name "bookmarks" user-emacs-directory))
  (setq bookmark-save-flag     t
        bookmark-default-file  my-bookmark-default-file)
#+END_SRC

*** Backups

By default, Emacs saves backup files in the current directory and, without
additional configuration, a backup for file =shopping= is named =shopping~=.
Emacs is the source of all of these files with tildies at the end of their names.
Here I configure Emacs to save all backups in one place. This has three disadvantages:

  - Files are no longer organized by the sensitivity of the data they hold. Previously,
    if sensitive data was being stored in a directory it's Emacs backups were co-located
    in the same directory. Making management of sensitive data a bit easier.
  - All Emacs backups will now consume storage on a single volume, unrelated to where
    the original data was being stored.
  - Backups are now hidden away in a directory that I am likely to look at infrequently.

These disadvantages are relatively minor and are outweighed, in my mind, by the advantage
of maintaining cleaner directories of just the files that I am working with.

#+BEGIN_SRC emacs-lisp
  (defconst my-backup-dir (expand-file-name "backups/" user-emacs-directory))
  (defconst my-auto-save-dir (expand-file-name "auto-save-list/" user-emacs-directory))

  (setq backup-directory-alist   `(("." . ,my-backup-dir))
        delete-old-versions      -1
        version-control          t     ; number the backup files
        vc-make-backup-file      t     ; make backups for files under vc
        auto-save-file-name-transforms  `((".*" ,my-auto-save-dir t)))
        history-length           1000
#+END_SRC

*** History

#+BEGIN_SRC emacs-lisp
  (setq savehist-file   (expand-file-name "savehist" user-emacs-directory)
        history-length  500
        savehist-additional-variables '(kill-ring search-ring regexp-search-ring))
#+END_SRC

*** Load path

Outside of the package system, I can add Emacs lisp functions in
a directory that I add to Emacs load path.

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/elisp")
#+END_SRC

*** Byte compiling

#+BEGIN_SRC emacs-lisp
(use-package auto-compile
  :config (auto-compile-on-load-mode)
  :init (setq load-prefer-newer t))
#+END_SRC

*** Civilized Emacs!

The most rudamentary requirements for text editing (but they can be overridden of course).

First deal with some whitespace issues:

  * Tell Emacs that sentences may end in a period followed by a single space.
  * Make sure saved files end in a newline.
  * Indentation shouldn't insert tabs.
  * Delete trailing whitespace from lines before saving.

#+BEGIN_SRC emacs-lisp
  (setq sentence-end-double-space nil
        require-final-newline     t
        indent-tabs-mode          nil)
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

Tweak the user interface to my liking.

  * No visible flashing, I prefer the beeps.
  * Reveal the cursor locations for non-selected windows (different shaped cursor)
  * Show the region in other windows
  * I've read the startup message thousands of times by now so turn it off.
  * Fringes, I'm not sure about. Trying out a new setting.
  * Save some space by hiding the tool-bar, no point in hiding the menu (most of the time).
  * Scroll bars, sometimes I like them sometimes I don't. They can stay in for now.

#+BEGIN_SRC emacs-lisp
  (setq visible-bell                   nil
        cursor-in-non-selected-windows t
        highlight-nonselected-windows  t
        inhibit-startup-message        t
        fringes-outside-margins        t)

  (when (fboundp 'tool-bar-mode)
    (tool-bar-mode -1))
#+END_SRC

Seeing matching parentheses is /very/ helpful while programming.

#+BEGIN_SRC emacs-lisp
  (show-paren-mode 1)
#+END_SRC

Help windows are selected automatically so that I can close them with just a
single key press (=q=) and get my windows back.

#+BEGIN_SRC emacs-lisp
  (setq help-window-select t)
#+END_SRC

* General configuration

** Elisp libraries

#+BEGIN_SRC emacs-lisp
(use-package dash)
#+END_SRC

** Appearance

** Splash Screen

Just like the Spacemacs dashboard!

#+BEGIN_SRC emacs-lisp
(use-package dashboard
  :init
  (setq dashboard-banner-logo-title "Welcome to Emacs"
        dashboard-startup-banner 'logo)
  :config
  ;; (add-to-list 'dashboard-items '(agenda) t)
  (add-hook 'dashboard-mode-hook
            (lambda () (set (make-local-variable 'mouse-1-click-follows-link) nil)))
  (dashboard-setup-startup-hook))
#+END_SRC

*** Themes

Now for some themes.

#+BEGIN_SRC emacs-lisp
  (use-package spacemacs-theme :defer)
  (use-package zenburn-theme :defer)
  (use-package solarized-theme :defer)
  (use-package leuven-theme :defer)
  (use-package color-theme-sanityinc-tomorrow :defer)
  (use-package monokai-theme :defer)
  (use-package material-theme :defer)
  (use-package moe-theme :defer)
  (use-package cyberpunk-theme :defer)
  (use-package ample-theme :defer)
  (use-package tango-plus-theme :defer)
  (use-package espresso-theme :defer)

  (load-theme 'spacemacs-light t)
#+END_SRC

** Time in the modeline

#+begin_src emacs-lisp
(display-time-mode 1)
#+end_src

* Extensions

** Avy

#+BEGIN_SRC emacs-lisp
  (use-package avy
    :bind
    ("<f8> j b" . pop-global-mark)
    ("<f8> j j" . avy-goto-char)
    ("<f8> j w" . avy-goto-word-1)
    ("<f8> j l" . avy-goto-line))

  (use-package avy-zap
    :bind
    ("M-z" . avy-zap-to-char-dwim)
    ("M-Z" . avy-zap-up-to-char-dwim))
#+END_SRC

** Company

#+BEGIN_SRC emacs-lisp
  (use-package company
    :delight
    :config
    (global-company-mode))
#+END_SRC

** Counsel and Ivy

See documentation at [[http://oremacs.com/swiper/][Ivy User Manual]]. During name completion, Ivy provides several
commands

*** Minibuffer key bindings

  - =C-a=, =C-f=, =M-d=, =M-DEL=, =M-b=, =M-w=, =C-k=, and =C-y= work as
    expected in the minibuffer the same way they work in fundamental-mode.
  - =C-n=, =C-p=, =M-<=, =M->=, =C-v=, =M-v= navigate through the candidates
    as one would expect.

*** Key bindings for single selection, action, then exit

  - =C-m= or =RET= :: Calls the default action then exits minibuffer.
  - =M-o= :: Presents action choices when there is more than one possible.
  - =C-j= :: When completing file names, selects current directory candidate
    and starts a new completion there.
  - =TAB= :: Attempts partial completion. =TAB TAB= is same as =C-j=.
  - =C-M-j= :: Exits with the current /input/ insead of current /candidate/.
    This is useful when using =find-file= to create a new file, but the desired
    name partially matches an existing file which you don't want to select.
  - =C-'= :: Avy selection of candidate.

*** Key bindings for multiple sections and actions, keeping minibuffer open

  - =C-M-m= :: Non-exiting version of =C-m=. For example try it in =describe-function=.
  - =C-M-o= :: Non-exiting version of =M-o=.
  - =C-M-n= :: Combines =C-n= and =C-M-m=. Good for opening several files.
  - =C-M-p= :: Combines =C-p= and =C-M-m=.
  - =ivy-resume= :: I've bound this to =C-c C-r=. Recalls the state of completion
    session just before its last exit. Useful after accidental =C-m=.

*** Key bindings that alter the minibuffer input

  Powerful capabilities that I need to learn to use.

  - =M-n= :: Cycle forward through Ivy command history. On empty history inserts
    symbol at point. (Not sure what this means.)
  - =M-p= :: Cycle to previous command history.
  - =M-i= :: Insert current candidate into minibuffer. Try it for renaming:
    =M-i= to insert original name, edit it, =C-m= to complete renaming. (I
    need to try this.)
  - =M-j= :: insert sub-word at point into the minibuffer. Similar to =C-s C-w=
    with =isearch=, but Ivy reserves =C-w= for =kill-region= as it is in
    fundamental mode.
  - =S-SPC= :: Deletes the current input and resets the candidates list to the
    currently restricted matches. Allows narrowing in successive steps.
  - =C-r= :: Reverse completion through the command's history. So easy way to
    find a recent file.

*** Other key bindings

  - =M-w= :: Copy selected candidates to the kill ring. Copies the region if active.

*** Hydra in the minibuffer

  =C-o= invokes the hydra menu with short key bindings.

*** Saving the current completion session to an occur buffer

  =C-c C-o= saves the current candidates to a new buffer. This buffer is
  read-only, but supports the following bindings.

  - =RET= :: Do current action on selected.
  - =mouse-1= :: Do current action on selected.
  - =j= :: Next line.
  - =k= :: Previouse line.
  - =a= :: Read an action and make it current
  - =o= :: Read an action and do it on selected candidate.
  - =q= :: Bury the current buffer.

*** File name competion

  - =C-j= :: On a directory, restart completion from that directory. On
    a file or =./=, exit completion with the selected candidate.
  - =DEL= :: Restart the completion in the parent directory if current input is
    empty.
  - =//= :: Switch to the root directory.
  - =~= :: Switch to the home directory.
  - =/= :: If the current input matches an existing directory name exactly,
    switch to that directory.
  - =M-r= :: Toggle between input as regexp or not. Since . matches anychar in
    regexp mode, use this to switch to literal matching mode.
  - =M-p=, =M-n=, =C-r= :: Move through file name completion from history of
    previously opened files.

*** TRAMP

  From any directory, with empty input, input =/ssh:= and press =RET=. Starts
  completion for host and user names. For =/ssh:user@= input, completes the
  domain name.

  Also =/sudo:: RET= does sudo access for the current directory. Using =/sudo:=,
  will do completion for the desired user.

*** Ivy and Counsel packages

  Ivy provides an elegant selection interface.
  I set =ivy-use-virtual-buffers= so that recent files are added to the
  buffer lists.

#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :delight ivy-mode
    :init
    (setq ivy-use-virtual-buffers t
          ivy-count-format "%d/%d ")
    :config
    (ivy-mode 1))

  (use-package ivy-hydra
    :after (ivy hydra))
#+END_SRC

  Counsel uses the Ivy selection interface to implement selection of files, buffers,
  etc.

#+BEGIN_SRC emacs-lisp
  (use-package counsel
    :delight counsel-mode
    :config
    (counsel-mode)
    :bind
    ; resume
    ("C-c C-r" . ivy-resume)
    ; files
    ("<f8> f f" . counsel-find-file)
    ("<f8> f l" . counsel-locate)
    ("<f8> f r" . counsel-recentf)
    ("<f8> f g" . counsel-git)
    ; buffers
    ("<f8> b b" . counsel-ibuffer)
    ; searching
    ("C-s" . swiper)
    ("<f8> / g" . counsel-git-grep)
    ("<f8> / a" . counsel-ag))
#+END_SRC

** Ediff

#+BEGIN_SRC emacs-lisp
  (use-package ediff
    :config
    (setq ediff-window-setup-function 'ediff-setup-windows-plain)
    (setq-default ediff-highlight-all-diffs 'nil)
    (setq ediff-diff-options "-w"))
#+END_SRC

** Eww

#+BEGIN_SRC emacs-lisp
(use-package eww
  :init
  (setq browse-url-browser-function
        '((".*google.*maps.*" . browse-url-generic)
          ;; Github goes to firefox, but not gist
          ("http.*\/\/github.com" . browse-url-generic)
          ("groups.google.com" . browse-url-generic)
          ("docs.google.com" . browse-url-generic)
          ("melpa.org" . browse-url-generic)
          ("stackoverflow\.com" . browse-url-generic)
          ; ("t.co" . browse-url-generic)
          ("twitter.com" . browse-url-generic)
          ("youtube.com" . browse-url-generic)
          ("amazon.com" . browse-url-generic)
          ("slideshare.net" . browse-url-generic)
          ("." . eww-browse-url)))
  (setq shr-external-browser 'browse-url-generic)
  (setq browse-url-generic-program (executable-find "firefox"))
  (add-hook 'eww-mode-hook #'toggle-word-wrap)
  (add-hook 'eww-mode-hook #'visual-line-mode)
  (add-hook 'eww-mode-hook #'tool-bar-mode)
  :config
  (use-package eww-lnum
    :config
    (bind-key "f" #'eww-lnum-follow eww-mode-map)
    (bind-key "U" #'eww-lnum-universal eww-mode-map)))

(use-package link-hint)

(defun browse-last-url-in-brower ()
  (interactive)
  (save-excursion
    (ffap-next-url t t)))

(global-set-key (kbd "C-c u") 'browse-last-url-in-brower)
#+END_SRC


** Expand region

#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :init
    (setq expand-region-contract-fast-key "V")
    (setq expand-region-reset-fast-key "r")
    :bind
    ("<f8> v" . er/expand-region))
#+END_SRC

** Flycheck

Be sure to see [[http://www.flycheck.org/en/latest/index.html][Flycheck documentation]].

#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :delight " Fc"
    :init (global-flycheck-mode))
#+END_SRC


** Hlinum and linum

The =linum= package numbers lines; the =hlinum= package highlights the current
line's line number.

#+BEGIN_SRC emacs-lisp
  (use-package hlinum
    :config
    (hlinum-activate))

  (use-package linum
    :config
    (setq linum-format " %3d ")
    :hook (prog-mode . linum-mode))
#+END_SRC

** Hydra

#+BEGIN_SRC emacs-lisp
    (require 'whitespace)
    (use-package hydra
      :config
      (defhydra hydra-toggle (:color pink)
        "
      _a_ abbrev-mode:      %`abbrev-mode
      _d_ debug-on-error:   %`debug-on-error
      _f_ auto-fill-mode:   %`auto-fill-function
      _t_ truncate-lines:   %`truncate-lines
      _v_ visual-line-mode: %`visual-line-mode
      _w_ whitespace-mode:  %`whitespace-mode
      "
      ("a" abbrev-mode nil)
      ("d" toggle-debug-on-error nil)
      ("f" auto-fill-mode nil)
      ("t" toggle-truncate-lines nil)
      ("v" visual-line-mode nil)
      ("w" whitespace-mode nil)
      ("q" nil "quit")))
#+END_SRC

** Magit

Org mode, Projectile, and Magit are key features of Emacs. This package, Magit, is
often cited as being the best interface to git.

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :init
    (setq magit-completing-read-function 'ivy-completing-read))

  (use-package magit-popup)
#+END_SRC

** Multiple cursors

Not really needed, see [[http://ergoemacs.org/misc/emacs_multiple-cursors-mode.html][Ergo Emacs on multiple cursors]].

Instead, some useful command to remember:

  - =M-z= :: =(zap-to-char)= kill up to and including ARGth occurrence of character.
    Actually bound in package =avy-zap= above.
  - =M-z char char C-b=  :: effect of zap-up-to-char.
  - =M-Z= :: =zap-up-to-char= is not an actual Emacs command, but I've bound this key
    above in =avy-zap= package.
  - =repeat-complex-command= :: normally bound to =C-x M-:=, but this is hard to type
    so rebind it to something a lot simpler to type.
  - Define a macro, select a region and use =M-x apply-macro-to-region-lines=.

#+BEGIN_SRC emacs-lisp
  (bind-key "<f8> ." 'repeat-complex-command)
#+END_SRC

** Neotree

#+BEGIN_SRC emacs-lisp
  (use-package neotree
    :init
    (setq neo-theme 'arrow
          neotree-smart-optn t
          neo-window-fixed-size nil)
    :bind
    ("<f8> d t" . neotree-toggle))

#+END_SRC

** Org

See [[http://pages.sachachua.com/.emacs.d/Sacha.html][Sacha Chua's Emacs configuration]] for lots of org-mode ideas.

#+BEGIN_SRC emacs-lisp
  (use-package org
    :delight "O"
    :mode "\\.org\'"
    :init
    (setq org-default-notes-file "~/notes.org"))
#+END_SRC

*** org-projectile

At some point I may want this package. Right now this is just a placeholder.

*** Org bullets

Install the package, but I really prefer the asterisks now.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package org-bullets)
#+END_SRC

** Page Break Lines

#+BEGIN_SRC emacs-lisp
  (use-package page-break-lines
    :config
    (global-page-break-lines-mode))
#+END_SRC

** Projectile

See the documentation at [[https://projectile.readthedocs.io/en/latest/][Projectile at readthedocs]].

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :delight '(:eval (concat " {" (projectile-project-name) "}"))
    :init
    (setq projectile-completion-system 'ivy)
    ; (setq projectile-keymap-prefix (kbd "<f8> p"))
    :config
    (projectile-global-mode))
#+END_SRC

  Although the =projectile= package supports Ivy as its completion system,
  =counsel-projectile= provides further integration.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package counsel-projectile
    :bind
    ("<f8> p SPC" . councel-projectile)
    ("<f8> p p"   . councel-projectile-switch-project)
    )
#+END_SRC

** Rainbow delimiters

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :hook ((prog-mode org-mode) . rainbow-delimiters-mode))
#+END_SRC

** Recentf

#+BEGIN_SRC emacs-lisp
  (use-package recentf
    :init
    (setq recent-save-file (expand-file-name "recentf" user-emacs-directory))
    :config
    (recentf-mode 1))
#+END_SRC

** Smartparens

#+BEGIN_SRC emacs-lisp
  (use-package smartparens)
#+END_SRC

** Undo Tree

#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :config
    (global-undo-tree-mode 1))
#+END_SRC

** wgrep

Placeholder, I'd like to try this out.

#+BEGIN_SRC emacs-lisp  :tangle no
  (use-package wgrep)
#+END_SRC

** Which key

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :delight which-key-mode
    :config
    (which-key-mode)
    ; (which-key-setup-side-window-right-bottom)
    (which-key-add-key-based-replacements
      "<f8> /" '("search" . "Search Commands")
      "<f8> b" '("buffer" . "Buffer Commands")
      "<f8> d" '("directory" . "Directory Commands")
      "<f8> f" '("file" . "File Commands")
      "<f8> g" '("magit" . "Magit Commands")
      )
    )
#+END_SRC

** Windmove

#+BEGIN_SRC emacs-lisp
  (use-package windmove
    :bind
    ("<f8> w u" . windmove-up)
    ("<f8> w d" . windmove-down)
    ("<f8> w l" . windmove-left)
    ("<f8> w r" . windmove-right))
#+END_SRC

** Winner mode - undo and redo window configuration

=winner-mode= lets you use =C-c <left>= and =C-c <right>=
to switch between window configurations.
This is handy when something has popped up a buffer that you want to look at
briefly before returning to whatever you were working on.
When you're done, press =C-c <left>=.

#+BEGIN_SRC emacs-lisp
(use-package winner)
#+END_SRC

** Yasnippet

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :config
    (yas-global-mode 1))
#+END_SRC

* Programming languages

#+BEGIN_SRC emacs-lisp

#+END_SRC

* Keybindings

The General package is a very flexible package for defining key bindings.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package general
    :commands general-define-key)
#+END_SRC

I use it to redefine a few default bindings.

#+BEGIN_SRC emacs-lisp :tangle no
  (general-define-key
   "C-s"     'swiper
   "M-x"     'counsel-M-x)
#+END_SRC

I redifine =C-x=, =C-h=, and =f1= bindings to take advantage of =councel=
and =ivy= packages.

#+BEGIN_SRC emacs-lisp :tangle no
;  (general-define-key
;   "C-x C-f"   'counsel-find-file
;   "C-x C-b"   'counsel-ibuffer
;   "C-x b"     'ivy-switch-buffer
;   "C-x l"     'counsel-locate
;   "C-x C-f"   'counsel-find-file

;   "C-h f"     'counsel-describe-function
;   "C-h v"     'counsel-describe-variable
;   "C-h l"     'counsel-find-library
;   "C-h S"     'counsel-info-lookup-symbol
;   "C-h u"     'counsel-unicode-char

;   "<f1> f"    'counsel-describe-function
;   "<f1> v"    'counsel-describe-variable
;   "<f1> l"    'counsel-find-library
;   "<f1> S"    'counsel-info-lookup-symbol
;   "<f1> u"    'counsel-unicode-char)
#+END_SRC

My =C-c= bindings

#+BEGIN_SRC emacs-lisp :tangle no
  (general-define-key
   :prefix "C-c"
   "g"   '(counsel-git :which-key "find file in git dir")
   "/"   'counsel-git-grep
   "k"   'counsel-ag
   "t"   'hydra-toggle/body

   "C-r" 'ivy-resume

   ;; binds to double key press
   "f"      '(:ignore t :which-key "files")
;   "ff"     'counsel-find-file    ; find file using ivy
   "fr"     'counsel-recentf      ; find recently edited files
   "fl"     'link-hint-open-link  ; open a link in a browser

   "p"      '(:ignore t :which-key "project")
   "pf"     '(counsel-git :which-key "find file in git dir"))
#+END_SRC
